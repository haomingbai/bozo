#include <bozo/connection_info.h>
#include <bozo/execute.h>
#include <bozo/transaction.h>
#include <bozo/shortcuts.h>
#include <bozo/request.h>
#include <bozo/pg/types/integer.h>

#include <boost/asio/io_service.hpp>
#include <boost/asio/spawn.hpp>

#include <iostream>

// This is an example of using the transaction mechanism is supplied by the library.
// It is based on https://www.postgresqltutorial.com/postgresql-transaction/.

namespace asio = boost::asio;

const auto throw_if_error = [](bozo::error_code ec, const auto& conn) {
    if (ec) {
        std::ostringstream s;
        if (!bozo::is_null_recursive(conn)) {
            s << "libpq error message: \"" << bozo::error_message(conn)
                << "\", error context: \"" << bozo::get_error_context(conn) << "\"";
        }
        throw bozo::system_error(ec, s.str());
    }
};

int main(int argc, char **argv) {
    std::cout << "BOZO request example" << std::endl;

    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <connection string>\n";
        return 1;
    }

    using namespace bozo::literals;
    using namespace std::chrono_literals;

    // Ozo perform all IO using Boost.Asio, so first thing we need to do is setup asio::io_context
    asio::io_context io;

    // To make a request we need to make a ConnectionSource. It knows how to connect to database using
    // connection string. See https://www.postgresql.org/docs/9.4/static/libpq-connect.html#LIBPQ-CONNSTRING
    // how to make a connection string.
    auto conn_info = bozo::connection_info(argv[1]);

    // All IO is asynchronous, therefore we have a choice here, what should be our CompletionToken.
    // We use Boost.Coroutines to write asynchronous code in synchronouse style. Coroutine will be
    // called after io.run() is called.
    asio::spawn(io, [&] (asio::yield_context yield) {
        bozo::error_code ec;

        // Prepare table and initial data for the example outside of transaction.
        // Assume that autocommit feature of PostrgreSQL is on by default
        auto conn = bozo::execute(conn_info[io], "DROP TABLE IF EXISTS accounts;"_SQL, yield);
        // Letâ€™s create a new table named accounts for the demonstration:
        conn = bozo::execute(std::move(conn),
            "CREATE TABLE accounts (\
                    id INT8 GENERATED BY DEFAULT AS IDENTITY,\
                    name TEXT NOT NULL,\
                    balance INT8 NOT NULL,\
                    PRIMARY KEY(id)\
            );"_SQL, yield);
        // When you execute the following INSERT statement PostgreSQL inserted a new row into the accounts table immediately.
        // In this case, you did not know when the transaction began and had no chance to intercept the change such as undoing it.
        conn = bozo::execute(std::move(conn), "INSERT INTO accounts(name,balance) VALUES('Bob',10000);"_SQL, yield);

        //! [Beginning a transaction]
        // To start a transaction, you use the following statement:
        auto transaction = bozo::begin(std::move(conn), yield[ec]);
        //! [Beginning a transaction]
        throw_if_error(ec, transaction);

        // The following statements insert a new account into the accounts table:
        transaction = bozo::execute(std::move(transaction), "INSERT INTO accounts(name,balance) VALUES('Alice',10000);"_SQL, yield[ec]);
        throw_if_error(ec, transaction);

        using rows_type = bozo::rows_of<bozo::pg::int8, bozo::pg::text, bozo::pg::int8>;
        const auto select_all = "SELECT id, name, balance FROM accounts"_SQL;
        rows_type result;

        const auto print_result = [](const rows_type& rows) {
            std::cout << "id\tname\tbalance\n";
            boost::for_each(rows, [](auto& x) {
                boost::hana::for_each(x, [&](auto& v) {
                    std::cout << v << '\t';
                });
                std::cout << '\n';
            });
        };

        // From the current session, you can see the change by querying the accounts table
        transaction = bozo::request(std::move(transaction), select_all, 1s, bozo::into(result), yield[ec]);
        throw_if_error(ec, transaction);

        print_result(result);
        // Should print:
        // id   name    balance
        // 1    Bob     10000
        // 2    Alice   10000

        result.clear();
        // However, in a new session with conn2 the query above should not observe the change
        auto conn2 = bozo::request(conn_info[io], select_all, 1s, bozo::into(result), yield[ec]);
        throw_if_error(ec, conn2);

        print_result(result);
        // Should print:
        // id   name    balance
        // 1    Bob     10000

        //! [Committing a transaction]
        // To make the change become visible to other sessions (or users) you need to commit the transaction
        // by using the following statement
        conn = bozo::commit(std::move(transaction), yield[ec]);
        //! [Committing a transaction]
        throw_if_error(ec, conn);

        // From any session, you can view this change by querying the accounts table
        result.clear();
        conn2 = bozo::request(std::move(conn2), select_all, 1s, bozo::into(result), yield[ec]);
        throw_if_error(ec, conn2);
        print_result(result);
        // Should print:
        // id   name    balance
        // 1    Bob     10000
        // 2    Alice   10000

        result.clear();
        conn = bozo::request(std::move(conn), select_all, 1s, bozo::into(result), yield[ec]);
        throw_if_error(ec, conn2);
        print_result(result);
        // Should print:
        // id   name    balance
        // 1    Bob     10000
        // 2    Alice   10000
    });

    io.run();

    return 0;
}
